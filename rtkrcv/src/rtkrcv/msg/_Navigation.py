"""autogenerated by genpy from rtkrcv/Navigation.msg. Do not edit."""
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import std_msgs.msg
import geometry_msgs.msg
import genpy
import rtkrcv.msg

class Navigation(genpy.Message):
  _md5sum = "650c43efcbdcf098fa315e28d42cc45d"
  _type = "rtkrcv/Navigation"
  _has_header = False #flag to mark the presence of a Header object
  _full_text = """# navigation data type









Ephemeris[] eph                     # GPS/QZS/GAL ephemeris
GlonassEphemeris[] geph             # GLONASS ephemeris
SbasEphemeris[] seph                # SBAS ephemeris
PreciseEphemeris[] peph             # precise ephemeris
PreciseClock[] pclk                 # precise clock
Almanac[] alm                       # almanac data
TotalElectronContent[] tec          # TEC grid data
stec_t[] stec                       # stec grid data 
erp_t erp                           # earth rotation parameters

float64[4] utc_gps                  # GPS delta-UTC parameters {A0,A1,T,W}
float64[4] utc_glo                  # GLONASS UTC GPS time parameters
float64[4] utc_gal                  # Galileo UTC GPS time parameters
float64[4] utc_qzs                  # QZS UTC GPS time parameters
float64[4] utc_cmp                  # BeiDou UTC parameters
float64[4] utc_sbs                  # SBAS UTC parameters 
float64[8] ion_gps                  # GPS iono model parameters {a0,a1,a2,a3,b0,b1,b2,b3}
float64[4] ion_gal                  # Galileo iono model parameters {ai0,ai1,ai2,0}
float64[8] ion_qzs                  # QZSS iono model parameters {a0,a1,a2,a3,b0,b1,b2,b3}
float64[8] ion_cmp                  # BeiDou iono model parameters {a0,a1,a2,a3,b0,b1,b2,b3} 
int32 leaps                         # leap seconds (s)

lam[] lamcwl                        # carrier wave lengths (m)
cbias[] codebias                    # code bias (0:p1-p2,1:p1-c1,2:p2-c2) (m)
AntennaParameter[] pcvs             # satellite antenna pcv
sbssat_t sbssat                     # SBAS satellite corrections
sbsion_t[] sbsion                   # SBAS ionosphere corrections
DifferentialGnss[] dgps             # DGPS corrections
ssr_t[] ssr                         # SSR corrections
QzssEphemeris[] lexeph              # LEX ephemeris
QzssIonosphereCorrection lexion     # LEX ionosphere correction

float64[] wlbias                    # wide-lane bias (cycle) 
float64[] glo_cpbias                # glonass code-phase bias {1C,1P,2C,2P} (m) 
uint8[] glo_fcn
================================================================================
MSG: rtkrcv/Ephemeris
# GPS/QZS/GAL broadcast ephemeris type

int32 sat             # satellite number
================================================================================
MSG: rtkrcv/GlonassEphemeris
# GLONASS broadcast ephemeris type

int32 sat                      # satellite number
int32 iode                     # IODE (0-6 bit of tb field)
int32 frq                      # satellite frequency number
int32 svh                      # satellite health
int32 sva                      # satellite accuracy
int32 age                      # satellite age of operation

time toe                       # epoch of epherides (gpst)
time tof                       # message frame time (gpst)

geometry_msgs/Vector3 pos      # satellite position (ecef) (m)
geometry_msgs/Vector3 vel      # satellite velocity (ecef) (m/s)
geometry_msgs/Vector3 acc      # satellite acceleration (ecef) (m/s^2)
float64 taun                   # SV clock bias (s)
float64 gamn                   # relative freq bias
float64 dtaun                  # delay between L1 and L2 (s)
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 

float64 x
float64 y
float64 z
================================================================================
MSG: rtkrcv/SbasEphemeris
# SBAS ephemeris type

int32 sat                       # satellite number
time t0                         # reference epoch time (GPST)
time tof                        # time of message frame (GPST)
int32 sva                       # SV accuracy (URA index)
int32 svh                       # SV health (0:ok)

geometry_msgs/Vector3 pos       # satellite position (m) (ecef)
geometry_msgs/Vector3 vel       # satellite velocity (m/s) (ecef)
geometry_msgs/Vector3 acc       # satellite acceleration (m/s^2) (ecef)
float64 af0                     # satellite clock-offset (s,s/s)
float64 af1                     # satellite drift (s,s/s)
================================================================================
MSG: rtkrcv/PreciseEphemeris
# precise ephemeris type

time time                 # time (GPST)
int32 index               # ephemeris index for multiple files
float64[] pos             # satellite position/clock (ecef) (m|s)
float32[] std             # satellite position/clock std (m|s)
================================================================================
MSG: rtkrcv/PreciseClock
# precise clock type

time time               # time (GPST)
int32 index             # clock index for multiple files
float64[] clk           # satellite clock (s)
float32[] std           # satellite clock std (s)
================================================================================
MSG: rtkrcv/Almanac
# The almanac consists of coarse orbit and status information for each satellite in the constellation, an ionospheric model, and information to relate GNSS derived time to Coordinated Universal Time (UTC)

int32 sat                     # satellite number
int32 svh                     # sv health (0:ok)
int32 svconf                  # as and sv config
int32 week                    # GPS/QZS: gps week, GAL: galileo week
Header toa                    # Toa

# SV orbit parameters
float64 A
float64 e
float64 i0
float64 OMG0
float64 omg
float64 M0
float64 OMGd

float64 toas                  # Toa (s) in week

# SV clock parameters (af0,af1)
float64 f0
float64 f1
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.secs: seconds (stamp_secs) since epoch
# * stamp.nsecs: nanoseconds since stamp_secs
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
# 0: no frame
# 1: global frame
string frame_id

================================================================================
MSG: rtkrcv/TotalElectronContent
# TEC type

time time                # epoch time (GPST)

int32[] ndata            # TEC grid data size {nlat,nlon,nhgt}

float64 rb               # earth radius (km)
float64[] lats           # latitude start/interval (deg)
float64[] lons           # longitude start/interval (deg)
float64[] hgts           # heights start/interval (km)
float64[] data           # TEC grid data (tecu)
float32[] rms            # RMS values (tecu)
================================================================================
MSG: rtkrcv/stec_t
# stec grid type

float64[] pos              #latitude/longitude (deg)
int32[] index              #search index
int32 n
int32 nmax                 #number of data
stecd_t[] data             #stec data

================================================================================
MSG: rtkrcv/stecd_t
# stec data type

Header header           #time (GPST)
uint8 sat               #satellite number
uint8 slip              #slip flag
float32 iono            #L1 ionosphere delay (m)
float32 rate            #L1 ionosphere rate (m/s)
float32 rms             #rms value (m)
================================================================================
MSG: rtkrcv/erp_t
# earth rotation parameter type

erpd_t[] data         # earth rotation parameter data
================================================================================
MSG: rtkrcv/erpd_t
# earth rotation parameter data type

float64 mjd                 # mjd (days)
float64 xp
float64 yp                  # pole offset (rad)
float64 xpr
float64 ypr                 # pole offset rate (rad/day)
float64 ut1_utc             # ut1-utc (s)
float64 lod                 # length of day (s/day)
================================================================================
MSG: rtkrcv/lam
#Datatype for lam message type (carrier wave lengths (m) )

float64 L1
float64 L2
float64 L5
float64 L6
float64 L7
float64 L8

================================================================================
MSG: rtkrcv/cbias
# code bias (0:p1-p2,1:p1-c1,2:p2-c2) (m)

float64 p1_p2
float64 p1_c1
float64 p2_c2
================================================================================
MSG: rtkrcv/AntennaParameter
# antenna parameter type

int32 sat              # satellite number (0:receiver)
int8[] type            # antenna type
int8[] code            # serial number or satellite code

time ts                # valid time start
time te                # valid time end

float64[3] off         # phase center offset e/n/u or x/y/z (m)
float64[19] var        # phase center variation (m)
                       # el=90,85,...,0 or nadir=0,1,2,3,... (deg)
================================================================================
MSG: rtkrcv/sbssat_t
# SBAS satellite corrections type

int32 iodp               # IODP (issue of date mask)
int32 nsat               # number of satellites
int32 tlat               # system latency (s)
sbssatp_t[] sat          # satellite correction
================================================================================
MSG: rtkrcv/sbssatp_t
# SBAS satellite correction type

int32 sat                                   # satellite number
SbasFastCorrection fcorr                    # fast correction
SbasLongTermErrorCorrection lcorr           # long term correction
================================================================================
MSG: rtkrcv/SbasFastCorrection
# SBAS fast correction type

time t0             # time of applicability (TOF)
float64 prc         # pseudorange correction (PRC) (m)
float64 rrc         # range-rate correction (RRC) (m/s)
float64 dt          # range-rate correction delta-time (s)
int32 iodf          # IODF (issue of date fast corr)
int16 udre          # UDRE+1
int16 ai            # degradation factor indicator
================================================================================
MSG: rtkrcv/SbasLongTermErrorCorrection
# SBAS long term satellite error correction type

time t0                        # correction time
int32 iode                     # IODE (issue of date ephemeris)
geometry_msgs/Vector3 dpos     # delta position (m) (ecef)
geometry_msgs/Vector3 dvel     # delta velocity (m/s) (ecef)
float64 daf0                   # delta clock-offset(s,s/s)
float64 daf1s                  # delta drift (s,s/s)

================================================================================
MSG: rtkrcv/sbsion_t
# SBAS ionospheric corrections type

int32 iodi                 # IODI (issue of date ionos corr)
int32 nigp                 # number of igps
sbsigp_t[] igp             # ionospheric correction
================================================================================
MSG: rtkrcv/sbsigp_t
# SBAS ionospheric correction type

time t0               # correction time
int16 lat             # latitude (deg)
int16 lon             # longitude (deg)
int16 give            # GIVI+1
float32 delay         # vertical delay estimate (m)
================================================================================
MSG: rtkrcv/DifferentialGnss
# DGPS/GNSS correction type

time t0             # correction time
float64 prc         # pseudorange correction (PRC) (m)
float64 rrc         # range rate correction (RRC) (m/s)
int32 iod           # issue of data (IOD)
float64 udre        # UDRE
================================================================================
MSG: rtkrcv/ssr_t
 # SSR correction type

time t0             # epoch time (GPST)
float64[] udi       # SSR update interval (s)
int32[] iod
int32 iode          # issue of data
int32 ura           # URA indicator
int32 refd          # sat ref datum (0:ITRF,1:regional)
float64[] deph      # delta orbit {radial,along,cross} (m)
float64[] ddeph     # dot delta orbit {radial,along,cross} (m/s)
float64[] dclk      # delta clock {c0,c1,c2} (m,m/s,m/s^2)
float64 hrclk       # high-rate clock corection (m)
float32[] cbias     # code biases (m)
uint8 update        # update flag (0:no update,1:update)
================================================================================
MSG: rtkrcv/QzssEphemeris
# QZSS LEX ephemeris type

time toe                             # epoch time (GPST)
time tof                             # message frame time (GPST)

int32 sat                            # satellite
uint8 health                         # signal health (L1,L2,L1C,L5,LEX)
uint8 ura                            # URA index

geometry_msgs/Vector3  pos           # satellite position (m)
geometry_msgs/Vector3  vel           # satellite velocity (m/s)
geometry_msgs/Vector3  acc           # satellite acceleration (m/s2)
geometry_msgs/Vector3  jerk          # satellite jerk (m/s3)
float64 af0                          # satellite clock bias
float64 af1                          # satellite clock drift (s,s/s)
float64 tgd                          # TGD
float64[] isc                        # ISC
================================================================================
MSG: rtkrcv/QzssIonosphereCorrection
# QZSS LEX ionosphere correction type

time t0                      # epoch time (GPST)
float64 tspan                # valid time span (s)
float64[2] pos0              # reference position {lat,lon} (rad)
float64[6] coefs             # coefficients lat x lon (3 x 2)
"""
  __slots__ = ['eph','geph','seph','peph','pclk','alm','tec','stec','erp','utc_gps','utc_glo','utc_gal','utc_qzs','utc_cmp','utc_sbs','ion_gps','ion_gal','ion_qzs','ion_cmp','leaps','lamcwl','codebias','pcvs','sbssat','sbsion','dgps','ssr','lexeph','lexion','wlbias','glo_cpbias','glo_fcn']
  _slot_types = ['rtkrcv/Ephemeris[]','rtkrcv/GlonassEphemeris[]','rtkrcv/SbasEphemeris[]','rtkrcv/PreciseEphemeris[]','rtkrcv/PreciseClock[]','rtkrcv/Almanac[]','rtkrcv/TotalElectronContent[]','rtkrcv/stec_t[]','rtkrcv/erp_t','float64[4]','float64[4]','float64[4]','float64[4]','float64[4]','float64[4]','float64[8]','float64[4]','float64[8]','float64[8]','int32','rtkrcv/lam[]','rtkrcv/cbias[]','rtkrcv/AntennaParameter[]','rtkrcv/sbssat_t','rtkrcv/sbsion_t[]','rtkrcv/DifferentialGnss[]','rtkrcv/ssr_t[]','rtkrcv/QzssEphemeris[]','rtkrcv/QzssIonosphereCorrection','float64[]','float64[]','uint8[]']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       eph,geph,seph,peph,pclk,alm,tec,stec,erp,utc_gps,utc_glo,utc_gal,utc_qzs,utc_cmp,utc_sbs,ion_gps,ion_gal,ion_qzs,ion_cmp,leaps,lamcwl,codebias,pcvs,sbssat,sbsion,dgps,ssr,lexeph,lexion,wlbias,glo_cpbias,glo_fcn

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(Navigation, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.eph is None:
        self.eph = []
      if self.geph is None:
        self.geph = []
      if self.seph is None:
        self.seph = []
      if self.peph is None:
        self.peph = []
      if self.pclk is None:
        self.pclk = []
      if self.alm is None:
        self.alm = []
      if self.tec is None:
        self.tec = []
      if self.stec is None:
        self.stec = []
      if self.erp is None:
        self.erp = rtkrcv.msg.erp_t()
      if self.utc_gps is None:
        self.utc_gps = [0.,0.,0.,0.]
      if self.utc_glo is None:
        self.utc_glo = [0.,0.,0.,0.]
      if self.utc_gal is None:
        self.utc_gal = [0.,0.,0.,0.]
      if self.utc_qzs is None:
        self.utc_qzs = [0.,0.,0.,0.]
      if self.utc_cmp is None:
        self.utc_cmp = [0.,0.,0.,0.]
      if self.utc_sbs is None:
        self.utc_sbs = [0.,0.,0.,0.]
      if self.ion_gps is None:
        self.ion_gps = [0.,0.,0.,0.,0.,0.,0.,0.]
      if self.ion_gal is None:
        self.ion_gal = [0.,0.,0.,0.]
      if self.ion_qzs is None:
        self.ion_qzs = [0.,0.,0.,0.,0.,0.,0.,0.]
      if self.ion_cmp is None:
        self.ion_cmp = [0.,0.,0.,0.,0.,0.,0.,0.]
      if self.leaps is None:
        self.leaps = 0
      if self.lamcwl is None:
        self.lamcwl = []
      if self.codebias is None:
        self.codebias = []
      if self.pcvs is None:
        self.pcvs = []
      if self.sbssat is None:
        self.sbssat = rtkrcv.msg.sbssat_t()
      if self.sbsion is None:
        self.sbsion = []
      if self.dgps is None:
        self.dgps = []
      if self.ssr is None:
        self.ssr = []
      if self.lexeph is None:
        self.lexeph = []
      if self.lexion is None:
        self.lexion = rtkrcv.msg.QzssIonosphereCorrection()
      if self.wlbias is None:
        self.wlbias = []
      if self.glo_cpbias is None:
        self.glo_cpbias = []
      if self.glo_fcn is None:
        self.glo_fcn = ''
    else:
      self.eph = []
      self.geph = []
      self.seph = []
      self.peph = []
      self.pclk = []
      self.alm = []
      self.tec = []
      self.stec = []
      self.erp = rtkrcv.msg.erp_t()
      self.utc_gps = [0.,0.,0.,0.]
      self.utc_glo = [0.,0.,0.,0.]
      self.utc_gal = [0.,0.,0.,0.]
      self.utc_qzs = [0.,0.,0.,0.]
      self.utc_cmp = [0.,0.,0.,0.]
      self.utc_sbs = [0.,0.,0.,0.]
      self.ion_gps = [0.,0.,0.,0.,0.,0.,0.,0.]
      self.ion_gal = [0.,0.,0.,0.]
      self.ion_qzs = [0.,0.,0.,0.,0.,0.,0.,0.]
      self.ion_cmp = [0.,0.,0.,0.,0.,0.,0.,0.]
      self.leaps = 0
      self.lamcwl = []
      self.codebias = []
      self.pcvs = []
      self.sbssat = rtkrcv.msg.sbssat_t()
      self.sbsion = []
      self.dgps = []
      self.ssr = []
      self.lexeph = []
      self.lexion = rtkrcv.msg.QzssIonosphereCorrection()
      self.wlbias = []
      self.glo_cpbias = []
      self.glo_fcn = ''

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      length = len(self.eph)
      buff.write(_struct_I.pack(length))
      for val1 in self.eph:
        buff.write(_struct_i.pack(val1.sat))
      length = len(self.geph)
      buff.write(_struct_I.pack(length))
      for val1 in self.geph:
        _x = val1
        buff.write(_struct_6i.pack(_x.sat, _x.iode, _x.frq, _x.svh, _x.sva, _x.age))
        _v1 = val1.toe
        _x = _v1
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        _v2 = val1.tof
        _x = _v2
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        _v3 = val1.pos
        _x = _v3
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _v4 = val1.vel
        _x = _v4
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _v5 = val1.acc
        _x = _v5
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _x = val1
        buff.write(_struct_3d.pack(_x.taun, _x.gamn, _x.dtaun))
      length = len(self.seph)
      buff.write(_struct_I.pack(length))
      for val1 in self.seph:
        buff.write(_struct_i.pack(val1.sat))
        _v6 = val1.t0
        _x = _v6
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        _v7 = val1.tof
        _x = _v7
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        _x = val1
        buff.write(_struct_2i.pack(_x.sva, _x.svh))
        _v8 = val1.pos
        _x = _v8
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _v9 = val1.vel
        _x = _v9
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _v10 = val1.acc
        _x = _v10
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _x = val1
        buff.write(_struct_2d.pack(_x.af0, _x.af1))
      length = len(self.peph)
      buff.write(_struct_I.pack(length))
      for val1 in self.peph:
        _v11 = val1.time
        _x = _v11
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        buff.write(_struct_i.pack(val1.index))
        length = len(val1.pos)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.pack(pattern, *val1.pos))
        length = len(val1.std)
        buff.write(_struct_I.pack(length))
        pattern = '<%sf'%length
        buff.write(struct.pack(pattern, *val1.std))
      length = len(self.pclk)
      buff.write(_struct_I.pack(length))
      for val1 in self.pclk:
        _v12 = val1.time
        _x = _v12
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        buff.write(_struct_i.pack(val1.index))
        length = len(val1.clk)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.pack(pattern, *val1.clk))
        length = len(val1.std)
        buff.write(_struct_I.pack(length))
        pattern = '<%sf'%length
        buff.write(struct.pack(pattern, *val1.std))
      length = len(self.alm)
      buff.write(_struct_I.pack(length))
      for val1 in self.alm:
        _x = val1
        buff.write(_struct_4i.pack(_x.sat, _x.svh, _x.svconf, _x.week))
        _v13 = val1.toa
        buff.write(_struct_I.pack(_v13.seq))
        _v14 = _v13.stamp
        _x = _v14
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        _x = _v13.frame_id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1
        buff.write(_struct_10d.pack(_x.A, _x.e, _x.i0, _x.OMG0, _x.omg, _x.M0, _x.OMGd, _x.toas, _x.f0, _x.f1))
      length = len(self.tec)
      buff.write(_struct_I.pack(length))
      for val1 in self.tec:
        _v15 = val1.time
        _x = _v15
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        length = len(val1.ndata)
        buff.write(_struct_I.pack(length))
        pattern = '<%si'%length
        buff.write(struct.pack(pattern, *val1.ndata))
        buff.write(_struct_d.pack(val1.rb))
        length = len(val1.lats)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.pack(pattern, *val1.lats))
        length = len(val1.lons)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.pack(pattern, *val1.lons))
        length = len(val1.hgts)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.pack(pattern, *val1.hgts))
        length = len(val1.data)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.pack(pattern, *val1.data))
        length = len(val1.rms)
        buff.write(_struct_I.pack(length))
        pattern = '<%sf'%length
        buff.write(struct.pack(pattern, *val1.rms))
      length = len(self.stec)
      buff.write(_struct_I.pack(length))
      for val1 in self.stec:
        length = len(val1.pos)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.pack(pattern, *val1.pos))
        length = len(val1.index)
        buff.write(_struct_I.pack(length))
        pattern = '<%si'%length
        buff.write(struct.pack(pattern, *val1.index))
        _x = val1
        buff.write(_struct_2i.pack(_x.n, _x.nmax))
        length = len(val1.data)
        buff.write(_struct_I.pack(length))
        for val2 in val1.data:
          _v16 = val2.header
          buff.write(_struct_I.pack(_v16.seq))
          _v17 = _v16.stamp
          _x = _v17
          buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
          _x = _v16.frame_id
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val2
          buff.write(_struct_2B3f.pack(_x.sat, _x.slip, _x.iono, _x.rate, _x.rms))
      length = len(self.erp.data)
      buff.write(_struct_I.pack(length))
      for val1 in self.erp.data:
        _x = val1
        buff.write(_struct_7d.pack(_x.mjd, _x.xp, _x.yp, _x.xpr, _x.ypr, _x.ut1_utc, _x.lod))
      buff.write(_struct_4d.pack(*self.utc_gps))
      buff.write(_struct_4d.pack(*self.utc_glo))
      buff.write(_struct_4d.pack(*self.utc_gal))
      buff.write(_struct_4d.pack(*self.utc_qzs))
      buff.write(_struct_4d.pack(*self.utc_cmp))
      buff.write(_struct_4d.pack(*self.utc_sbs))
      buff.write(_struct_8d.pack(*self.ion_gps))
      buff.write(_struct_4d.pack(*self.ion_gal))
      buff.write(_struct_8d.pack(*self.ion_qzs))
      buff.write(_struct_8d.pack(*self.ion_cmp))
      buff.write(_struct_i.pack(self.leaps))
      length = len(self.lamcwl)
      buff.write(_struct_I.pack(length))
      for val1 in self.lamcwl:
        _x = val1
        buff.write(_struct_6d.pack(_x.L1, _x.L2, _x.L5, _x.L6, _x.L7, _x.L8))
      length = len(self.codebias)
      buff.write(_struct_I.pack(length))
      for val1 in self.codebias:
        _x = val1
        buff.write(_struct_3d.pack(_x.p1_p2, _x.p1_c1, _x.p2_c2))
      length = len(self.pcvs)
      buff.write(_struct_I.pack(length))
      for val1 in self.pcvs:
        buff.write(_struct_i.pack(val1.sat))
        length = len(val1.type)
        buff.write(_struct_I.pack(length))
        pattern = '<%sb'%length
        buff.write(struct.pack(pattern, *val1.type))
        length = len(val1.code)
        buff.write(_struct_I.pack(length))
        pattern = '<%sb'%length
        buff.write(struct.pack(pattern, *val1.code))
        _v18 = val1.ts
        _x = _v18
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        _v19 = val1.te
        _x = _v19
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        buff.write(_struct_3d.pack(*val1.off))
        buff.write(_struct_19d.pack(*val1.var))
      _x = self
      buff.write(_struct_3i.pack(_x.sbssat.iodp, _x.sbssat.nsat, _x.sbssat.tlat))
      length = len(self.sbssat.sat)
      buff.write(_struct_I.pack(length))
      for val1 in self.sbssat.sat:
        buff.write(_struct_i.pack(val1.sat))
        _v20 = val1.fcorr
        _v21 = _v20.t0
        _x = _v21
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        _x = _v20
        buff.write(_struct_3di2h.pack(_x.prc, _x.rrc, _x.dt, _x.iodf, _x.udre, _x.ai))
        _v22 = val1.lcorr
        _v23 = _v22.t0
        _x = _v23
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        buff.write(_struct_i.pack(_v22.iode))
        _v24 = _v22.dpos
        _x = _v24
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _v25 = _v22.dvel
        _x = _v25
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _x = _v22
        buff.write(_struct_2d.pack(_x.daf0, _x.daf1s))
      length = len(self.sbsion)
      buff.write(_struct_I.pack(length))
      for val1 in self.sbsion:
        _x = val1
        buff.write(_struct_2i.pack(_x.iodi, _x.nigp))
        length = len(val1.igp)
        buff.write(_struct_I.pack(length))
        for val2 in val1.igp:
          _v26 = val2.t0
          _x = _v26
          buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
          _x = val2
          buff.write(_struct_3hf.pack(_x.lat, _x.lon, _x.give, _x.delay))
      length = len(self.dgps)
      buff.write(_struct_I.pack(length))
      for val1 in self.dgps:
        _v27 = val1.t0
        _x = _v27
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        _x = val1
        buff.write(_struct_2did.pack(_x.prc, _x.rrc, _x.iod, _x.udre))
      length = len(self.ssr)
      buff.write(_struct_I.pack(length))
      for val1 in self.ssr:
        _v28 = val1.t0
        _x = _v28
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        length = len(val1.udi)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.pack(pattern, *val1.udi))
        length = len(val1.iod)
        buff.write(_struct_I.pack(length))
        pattern = '<%si'%length
        buff.write(struct.pack(pattern, *val1.iod))
        _x = val1
        buff.write(_struct_3i.pack(_x.iode, _x.ura, _x.refd))
        length = len(val1.deph)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.pack(pattern, *val1.deph))
        length = len(val1.ddeph)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.pack(pattern, *val1.ddeph))
        length = len(val1.dclk)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.pack(pattern, *val1.dclk))
        buff.write(_struct_d.pack(val1.hrclk))
        length = len(val1.cbias)
        buff.write(_struct_I.pack(length))
        pattern = '<%sf'%length
        buff.write(struct.pack(pattern, *val1.cbias))
        buff.write(_struct_B.pack(val1.update))
      length = len(self.lexeph)
      buff.write(_struct_I.pack(length))
      for val1 in self.lexeph:
        _v29 = val1.toe
        _x = _v29
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        _v30 = val1.tof
        _x = _v30
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        _x = val1
        buff.write(_struct_i2B.pack(_x.sat, _x.health, _x.ura))
        _v31 = val1.pos
        _x = _v31
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _v32 = val1.vel
        _x = _v32
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _v33 = val1.acc
        _x = _v33
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _v34 = val1.jerk
        _x = _v34
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _x = val1
        buff.write(_struct_3d.pack(_x.af0, _x.af1, _x.tgd))
        length = len(val1.isc)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.pack(pattern, *val1.isc))
      _x = self
      buff.write(_struct_2Id.pack(_x.lexion.t0.secs, _x.lexion.t0.nsecs, _x.lexion.tspan))
      buff.write(_struct_2d.pack(*self.lexion.pos0))
      buff.write(_struct_6d.pack(*self.lexion.coefs))
      length = len(self.wlbias)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.wlbias))
      length = len(self.glo_cpbias)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.glo_cpbias))
      _x = self.glo_fcn
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(_x))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(_x))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    try:
      if self.eph is None:
        self.eph = None
      if self.geph is None:
        self.geph = None
      if self.seph is None:
        self.seph = None
      if self.peph is None:
        self.peph = None
      if self.pclk is None:
        self.pclk = None
      if self.alm is None:
        self.alm = None
      if self.tec is None:
        self.tec = None
      if self.stec is None:
        self.stec = None
      if self.erp is None:
        self.erp = rtkrcv.msg.erp_t()
      if self.lamcwl is None:
        self.lamcwl = None
      if self.codebias is None:
        self.codebias = None
      if self.pcvs is None:
        self.pcvs = None
      if self.sbssat is None:
        self.sbssat = rtkrcv.msg.sbssat_t()
      if self.sbsion is None:
        self.sbsion = None
      if self.dgps is None:
        self.dgps = None
      if self.ssr is None:
        self.ssr = None
      if self.lexeph is None:
        self.lexeph = None
      if self.lexion is None:
        self.lexion = rtkrcv.msg.QzssIonosphereCorrection()
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.eph = []
      for i in range(0, length):
        val1 = rtkrcv.msg.Ephemeris()
        start = end
        end += 4
        (val1.sat,) = _struct_i.unpack(str[start:end])
        self.eph.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.geph = []
      for i in range(0, length):
        val1 = rtkrcv.msg.GlonassEphemeris()
        _x = val1
        start = end
        end += 24
        (_x.sat, _x.iode, _x.frq, _x.svh, _x.sva, _x.age,) = _struct_6i.unpack(str[start:end])
        _v35 = val1.toe
        _x = _v35
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        _v36 = val1.tof
        _x = _v36
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        _v37 = val1.pos
        _x = _v37
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _v38 = val1.vel
        _x = _v38
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _v39 = val1.acc
        _x = _v39
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _x = val1
        start = end
        end += 24
        (_x.taun, _x.gamn, _x.dtaun,) = _struct_3d.unpack(str[start:end])
        self.geph.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.seph = []
      for i in range(0, length):
        val1 = rtkrcv.msg.SbasEphemeris()
        start = end
        end += 4
        (val1.sat,) = _struct_i.unpack(str[start:end])
        _v40 = val1.t0
        _x = _v40
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        _v41 = val1.tof
        _x = _v41
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        _x = val1
        start = end
        end += 8
        (_x.sva, _x.svh,) = _struct_2i.unpack(str[start:end])
        _v42 = val1.pos
        _x = _v42
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _v43 = val1.vel
        _x = _v43
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _v44 = val1.acc
        _x = _v44
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _x = val1
        start = end
        end += 16
        (_x.af0, _x.af1,) = _struct_2d.unpack(str[start:end])
        self.seph.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.peph = []
      for i in range(0, length):
        val1 = rtkrcv.msg.PreciseEphemeris()
        _v45 = val1.time
        _x = _v45
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        start = end
        end += 4
        (val1.index,) = _struct_i.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        end += struct.calcsize(pattern)
        val1.pos = struct.unpack(pattern, str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sf'%length
        start = end
        end += struct.calcsize(pattern)
        val1.std = struct.unpack(pattern, str[start:end])
        self.peph.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.pclk = []
      for i in range(0, length):
        val1 = rtkrcv.msg.PreciseClock()
        _v46 = val1.time
        _x = _v46
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        start = end
        end += 4
        (val1.index,) = _struct_i.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        end += struct.calcsize(pattern)
        val1.clk = struct.unpack(pattern, str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sf'%length
        start = end
        end += struct.calcsize(pattern)
        val1.std = struct.unpack(pattern, str[start:end])
        self.pclk.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.alm = []
      for i in range(0, length):
        val1 = rtkrcv.msg.Almanac()
        _x = val1
        start = end
        end += 16
        (_x.sat, _x.svh, _x.svconf, _x.week,) = _struct_4i.unpack(str[start:end])
        _v47 = val1.toa
        start = end
        end += 4
        (_v47.seq,) = _struct_I.unpack(str[start:end])
        _v48 = _v47.stamp
        _x = _v48
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v47.frame_id = str[start:end].decode('utf-8')
        else:
          _v47.frame_id = str[start:end]
        _x = val1
        start = end
        end += 80
        (_x.A, _x.e, _x.i0, _x.OMG0, _x.omg, _x.M0, _x.OMGd, _x.toas, _x.f0, _x.f1,) = _struct_10d.unpack(str[start:end])
        self.alm.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.tec = []
      for i in range(0, length):
        val1 = rtkrcv.msg.TotalElectronContent()
        _v49 = val1.time
        _x = _v49
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%si'%length
        start = end
        end += struct.calcsize(pattern)
        val1.ndata = struct.unpack(pattern, str[start:end])
        start = end
        end += 8
        (val1.rb,) = _struct_d.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        end += struct.calcsize(pattern)
        val1.lats = struct.unpack(pattern, str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        end += struct.calcsize(pattern)
        val1.lons = struct.unpack(pattern, str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        end += struct.calcsize(pattern)
        val1.hgts = struct.unpack(pattern, str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        end += struct.calcsize(pattern)
        val1.data = struct.unpack(pattern, str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sf'%length
        start = end
        end += struct.calcsize(pattern)
        val1.rms = struct.unpack(pattern, str[start:end])
        self.tec.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.stec = []
      for i in range(0, length):
        val1 = rtkrcv.msg.stec_t()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        end += struct.calcsize(pattern)
        val1.pos = struct.unpack(pattern, str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%si'%length
        start = end
        end += struct.calcsize(pattern)
        val1.index = struct.unpack(pattern, str[start:end])
        _x = val1
        start = end
        end += 8
        (_x.n, _x.nmax,) = _struct_2i.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.data = []
        for i in range(0, length):
          val2 = rtkrcv.msg.stecd_t()
          _v50 = val2.header
          start = end
          end += 4
          (_v50.seq,) = _struct_I.unpack(str[start:end])
          _v51 = _v50.stamp
          _x = _v51
          start = end
          end += 8
          (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            _v50.frame_id = str[start:end].decode('utf-8')
          else:
            _v50.frame_id = str[start:end]
          _x = val2
          start = end
          end += 14
          (_x.sat, _x.slip, _x.iono, _x.rate, _x.rms,) = _struct_2B3f.unpack(str[start:end])
          val1.data.append(val2)
        self.stec.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.erp.data = []
      for i in range(0, length):
        val1 = rtkrcv.msg.erpd_t()
        _x = val1
        start = end
        end += 56
        (_x.mjd, _x.xp, _x.yp, _x.xpr, _x.ypr, _x.ut1_utc, _x.lod,) = _struct_7d.unpack(str[start:end])
        self.erp.data.append(val1)
      start = end
      end += 32
      self.utc_gps = _struct_4d.unpack(str[start:end])
      start = end
      end += 32
      self.utc_glo = _struct_4d.unpack(str[start:end])
      start = end
      end += 32
      self.utc_gal = _struct_4d.unpack(str[start:end])
      start = end
      end += 32
      self.utc_qzs = _struct_4d.unpack(str[start:end])
      start = end
      end += 32
      self.utc_cmp = _struct_4d.unpack(str[start:end])
      start = end
      end += 32
      self.utc_sbs = _struct_4d.unpack(str[start:end])
      start = end
      end += 64
      self.ion_gps = _struct_8d.unpack(str[start:end])
      start = end
      end += 32
      self.ion_gal = _struct_4d.unpack(str[start:end])
      start = end
      end += 64
      self.ion_qzs = _struct_8d.unpack(str[start:end])
      start = end
      end += 64
      self.ion_cmp = _struct_8d.unpack(str[start:end])
      start = end
      end += 4
      (self.leaps,) = _struct_i.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.lamcwl = []
      for i in range(0, length):
        val1 = rtkrcv.msg.lam()
        _x = val1
        start = end
        end += 48
        (_x.L1, _x.L2, _x.L5, _x.L6, _x.L7, _x.L8,) = _struct_6d.unpack(str[start:end])
        self.lamcwl.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.codebias = []
      for i in range(0, length):
        val1 = rtkrcv.msg.cbias()
        _x = val1
        start = end
        end += 24
        (_x.p1_p2, _x.p1_c1, _x.p2_c2,) = _struct_3d.unpack(str[start:end])
        self.codebias.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.pcvs = []
      for i in range(0, length):
        val1 = rtkrcv.msg.AntennaParameter()
        start = end
        end += 4
        (val1.sat,) = _struct_i.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sb'%length
        start = end
        end += struct.calcsize(pattern)
        val1.type = struct.unpack(pattern, str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sb'%length
        start = end
        end += struct.calcsize(pattern)
        val1.code = struct.unpack(pattern, str[start:end])
        _v52 = val1.ts
        _x = _v52
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        _v53 = val1.te
        _x = _v53
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        start = end
        end += 24
        val1.off = _struct_3d.unpack(str[start:end])
        start = end
        end += 152
        val1.var = _struct_19d.unpack(str[start:end])
        self.pcvs.append(val1)
      _x = self
      start = end
      end += 12
      (_x.sbssat.iodp, _x.sbssat.nsat, _x.sbssat.tlat,) = _struct_3i.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.sbssat.sat = []
      for i in range(0, length):
        val1 = rtkrcv.msg.sbssatp_t()
        start = end
        end += 4
        (val1.sat,) = _struct_i.unpack(str[start:end])
        _v54 = val1.fcorr
        _v55 = _v54.t0
        _x = _v55
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        _x = _v54
        start = end
        end += 32
        (_x.prc, _x.rrc, _x.dt, _x.iodf, _x.udre, _x.ai,) = _struct_3di2h.unpack(str[start:end])
        _v56 = val1.lcorr
        _v57 = _v56.t0
        _x = _v57
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        start = end
        end += 4
        (_v56.iode,) = _struct_i.unpack(str[start:end])
        _v58 = _v56.dpos
        _x = _v58
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _v59 = _v56.dvel
        _x = _v59
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _x = _v56
        start = end
        end += 16
        (_x.daf0, _x.daf1s,) = _struct_2d.unpack(str[start:end])
        self.sbssat.sat.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.sbsion = []
      for i in range(0, length):
        val1 = rtkrcv.msg.sbsion_t()
        _x = val1
        start = end
        end += 8
        (_x.iodi, _x.nigp,) = _struct_2i.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.igp = []
        for i in range(0, length):
          val2 = rtkrcv.msg.sbsigp_t()
          _v60 = val2.t0
          _x = _v60
          start = end
          end += 8
          (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
          _x = val2
          start = end
          end += 10
          (_x.lat, _x.lon, _x.give, _x.delay,) = _struct_3hf.unpack(str[start:end])
          val1.igp.append(val2)
        self.sbsion.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.dgps = []
      for i in range(0, length):
        val1 = rtkrcv.msg.DifferentialGnss()
        _v61 = val1.t0
        _x = _v61
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        _x = val1
        start = end
        end += 28
        (_x.prc, _x.rrc, _x.iod, _x.udre,) = _struct_2did.unpack(str[start:end])
        self.dgps.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.ssr = []
      for i in range(0, length):
        val1 = rtkrcv.msg.ssr_t()
        _v62 = val1.t0
        _x = _v62
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        end += struct.calcsize(pattern)
        val1.udi = struct.unpack(pattern, str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%si'%length
        start = end
        end += struct.calcsize(pattern)
        val1.iod = struct.unpack(pattern, str[start:end])
        _x = val1
        start = end
        end += 12
        (_x.iode, _x.ura, _x.refd,) = _struct_3i.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        end += struct.calcsize(pattern)
        val1.deph = struct.unpack(pattern, str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        end += struct.calcsize(pattern)
        val1.ddeph = struct.unpack(pattern, str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        end += struct.calcsize(pattern)
        val1.dclk = struct.unpack(pattern, str[start:end])
        start = end
        end += 8
        (val1.hrclk,) = _struct_d.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sf'%length
        start = end
        end += struct.calcsize(pattern)
        val1.cbias = struct.unpack(pattern, str[start:end])
        start = end
        end += 1
        (val1.update,) = _struct_B.unpack(str[start:end])
        self.ssr.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.lexeph = []
      for i in range(0, length):
        val1 = rtkrcv.msg.QzssEphemeris()
        _v63 = val1.toe
        _x = _v63
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        _v64 = val1.tof
        _x = _v64
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        _x = val1
        start = end
        end += 6
        (_x.sat, _x.health, _x.ura,) = _struct_i2B.unpack(str[start:end])
        _v65 = val1.pos
        _x = _v65
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _v66 = val1.vel
        _x = _v66
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _v67 = val1.acc
        _x = _v67
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _v68 = val1.jerk
        _x = _v68
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _x = val1
        start = end
        end += 24
        (_x.af0, _x.af1, _x.tgd,) = _struct_3d.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        end += struct.calcsize(pattern)
        val1.isc = struct.unpack(pattern, str[start:end])
        self.lexeph.append(val1)
      _x = self
      start = end
      end += 16
      (_x.lexion.t0.secs, _x.lexion.t0.nsecs, _x.lexion.tspan,) = _struct_2Id.unpack(str[start:end])
      start = end
      end += 16
      self.lexion.pos0 = _struct_2d.unpack(str[start:end])
      start = end
      end += 48
      self.lexion.coefs = _struct_6d.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.wlbias = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.glo_cpbias = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.glo_fcn = str[start:end]
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      length = len(self.eph)
      buff.write(_struct_I.pack(length))
      for val1 in self.eph:
        buff.write(_struct_i.pack(val1.sat))
      length = len(self.geph)
      buff.write(_struct_I.pack(length))
      for val1 in self.geph:
        _x = val1
        buff.write(_struct_6i.pack(_x.sat, _x.iode, _x.frq, _x.svh, _x.sva, _x.age))
        _v69 = val1.toe
        _x = _v69
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        _v70 = val1.tof
        _x = _v70
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        _v71 = val1.pos
        _x = _v71
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _v72 = val1.vel
        _x = _v72
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _v73 = val1.acc
        _x = _v73
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _x = val1
        buff.write(_struct_3d.pack(_x.taun, _x.gamn, _x.dtaun))
      length = len(self.seph)
      buff.write(_struct_I.pack(length))
      for val1 in self.seph:
        buff.write(_struct_i.pack(val1.sat))
        _v74 = val1.t0
        _x = _v74
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        _v75 = val1.tof
        _x = _v75
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        _x = val1
        buff.write(_struct_2i.pack(_x.sva, _x.svh))
        _v76 = val1.pos
        _x = _v76
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _v77 = val1.vel
        _x = _v77
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _v78 = val1.acc
        _x = _v78
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _x = val1
        buff.write(_struct_2d.pack(_x.af0, _x.af1))
      length = len(self.peph)
      buff.write(_struct_I.pack(length))
      for val1 in self.peph:
        _v79 = val1.time
        _x = _v79
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        buff.write(_struct_i.pack(val1.index))
        length = len(val1.pos)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(val1.pos.tostring())
        length = len(val1.std)
        buff.write(_struct_I.pack(length))
        pattern = '<%sf'%length
        buff.write(val1.std.tostring())
      length = len(self.pclk)
      buff.write(_struct_I.pack(length))
      for val1 in self.pclk:
        _v80 = val1.time
        _x = _v80
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        buff.write(_struct_i.pack(val1.index))
        length = len(val1.clk)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(val1.clk.tostring())
        length = len(val1.std)
        buff.write(_struct_I.pack(length))
        pattern = '<%sf'%length
        buff.write(val1.std.tostring())
      length = len(self.alm)
      buff.write(_struct_I.pack(length))
      for val1 in self.alm:
        _x = val1
        buff.write(_struct_4i.pack(_x.sat, _x.svh, _x.svconf, _x.week))
        _v81 = val1.toa
        buff.write(_struct_I.pack(_v81.seq))
        _v82 = _v81.stamp
        _x = _v82
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        _x = _v81.frame_id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1
        buff.write(_struct_10d.pack(_x.A, _x.e, _x.i0, _x.OMG0, _x.omg, _x.M0, _x.OMGd, _x.toas, _x.f0, _x.f1))
      length = len(self.tec)
      buff.write(_struct_I.pack(length))
      for val1 in self.tec:
        _v83 = val1.time
        _x = _v83
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        length = len(val1.ndata)
        buff.write(_struct_I.pack(length))
        pattern = '<%si'%length
        buff.write(val1.ndata.tostring())
        buff.write(_struct_d.pack(val1.rb))
        length = len(val1.lats)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(val1.lats.tostring())
        length = len(val1.lons)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(val1.lons.tostring())
        length = len(val1.hgts)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(val1.hgts.tostring())
        length = len(val1.data)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(val1.data.tostring())
        length = len(val1.rms)
        buff.write(_struct_I.pack(length))
        pattern = '<%sf'%length
        buff.write(val1.rms.tostring())
      length = len(self.stec)
      buff.write(_struct_I.pack(length))
      for val1 in self.stec:
        length = len(val1.pos)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(val1.pos.tostring())
        length = len(val1.index)
        buff.write(_struct_I.pack(length))
        pattern = '<%si'%length
        buff.write(val1.index.tostring())
        _x = val1
        buff.write(_struct_2i.pack(_x.n, _x.nmax))
        length = len(val1.data)
        buff.write(_struct_I.pack(length))
        for val2 in val1.data:
          _v84 = val2.header
          buff.write(_struct_I.pack(_v84.seq))
          _v85 = _v84.stamp
          _x = _v85
          buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
          _x = _v84.frame_id
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val2
          buff.write(_struct_2B3f.pack(_x.sat, _x.slip, _x.iono, _x.rate, _x.rms))
      length = len(self.erp.data)
      buff.write(_struct_I.pack(length))
      for val1 in self.erp.data:
        _x = val1
        buff.write(_struct_7d.pack(_x.mjd, _x.xp, _x.yp, _x.xpr, _x.ypr, _x.ut1_utc, _x.lod))
      buff.write(self.utc_gps.tostring())
      buff.write(self.utc_glo.tostring())
      buff.write(self.utc_gal.tostring())
      buff.write(self.utc_qzs.tostring())
      buff.write(self.utc_cmp.tostring())
      buff.write(self.utc_sbs.tostring())
      buff.write(self.ion_gps.tostring())
      buff.write(self.ion_gal.tostring())
      buff.write(self.ion_qzs.tostring())
      buff.write(self.ion_cmp.tostring())
      buff.write(_struct_i.pack(self.leaps))
      length = len(self.lamcwl)
      buff.write(_struct_I.pack(length))
      for val1 in self.lamcwl:
        _x = val1
        buff.write(_struct_6d.pack(_x.L1, _x.L2, _x.L5, _x.L6, _x.L7, _x.L8))
      length = len(self.codebias)
      buff.write(_struct_I.pack(length))
      for val1 in self.codebias:
        _x = val1
        buff.write(_struct_3d.pack(_x.p1_p2, _x.p1_c1, _x.p2_c2))
      length = len(self.pcvs)
      buff.write(_struct_I.pack(length))
      for val1 in self.pcvs:
        buff.write(_struct_i.pack(val1.sat))
        length = len(val1.type)
        buff.write(_struct_I.pack(length))
        pattern = '<%sb'%length
        buff.write(val1.type.tostring())
        length = len(val1.code)
        buff.write(_struct_I.pack(length))
        pattern = '<%sb'%length
        buff.write(val1.code.tostring())
        _v86 = val1.ts
        _x = _v86
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        _v87 = val1.te
        _x = _v87
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        buff.write(val1.off.tostring())
        buff.write(val1.var.tostring())
      _x = self
      buff.write(_struct_3i.pack(_x.sbssat.iodp, _x.sbssat.nsat, _x.sbssat.tlat))
      length = len(self.sbssat.sat)
      buff.write(_struct_I.pack(length))
      for val1 in self.sbssat.sat:
        buff.write(_struct_i.pack(val1.sat))
        _v88 = val1.fcorr
        _v89 = _v88.t0
        _x = _v89
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        _x = _v88
        buff.write(_struct_3di2h.pack(_x.prc, _x.rrc, _x.dt, _x.iodf, _x.udre, _x.ai))
        _v90 = val1.lcorr
        _v91 = _v90.t0
        _x = _v91
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        buff.write(_struct_i.pack(_v90.iode))
        _v92 = _v90.dpos
        _x = _v92
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _v93 = _v90.dvel
        _x = _v93
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _x = _v90
        buff.write(_struct_2d.pack(_x.daf0, _x.daf1s))
      length = len(self.sbsion)
      buff.write(_struct_I.pack(length))
      for val1 in self.sbsion:
        _x = val1
        buff.write(_struct_2i.pack(_x.iodi, _x.nigp))
        length = len(val1.igp)
        buff.write(_struct_I.pack(length))
        for val2 in val1.igp:
          _v94 = val2.t0
          _x = _v94
          buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
          _x = val2
          buff.write(_struct_3hf.pack(_x.lat, _x.lon, _x.give, _x.delay))
      length = len(self.dgps)
      buff.write(_struct_I.pack(length))
      for val1 in self.dgps:
        _v95 = val1.t0
        _x = _v95
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        _x = val1
        buff.write(_struct_2did.pack(_x.prc, _x.rrc, _x.iod, _x.udre))
      length = len(self.ssr)
      buff.write(_struct_I.pack(length))
      for val1 in self.ssr:
        _v96 = val1.t0
        _x = _v96
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        length = len(val1.udi)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(val1.udi.tostring())
        length = len(val1.iod)
        buff.write(_struct_I.pack(length))
        pattern = '<%si'%length
        buff.write(val1.iod.tostring())
        _x = val1
        buff.write(_struct_3i.pack(_x.iode, _x.ura, _x.refd))
        length = len(val1.deph)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(val1.deph.tostring())
        length = len(val1.ddeph)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(val1.ddeph.tostring())
        length = len(val1.dclk)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(val1.dclk.tostring())
        buff.write(_struct_d.pack(val1.hrclk))
        length = len(val1.cbias)
        buff.write(_struct_I.pack(length))
        pattern = '<%sf'%length
        buff.write(val1.cbias.tostring())
        buff.write(_struct_B.pack(val1.update))
      length = len(self.lexeph)
      buff.write(_struct_I.pack(length))
      for val1 in self.lexeph:
        _v97 = val1.toe
        _x = _v97
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        _v98 = val1.tof
        _x = _v98
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        _x = val1
        buff.write(_struct_i2B.pack(_x.sat, _x.health, _x.ura))
        _v99 = val1.pos
        _x = _v99
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _v100 = val1.vel
        _x = _v100
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _v101 = val1.acc
        _x = _v101
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _v102 = val1.jerk
        _x = _v102
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _x = val1
        buff.write(_struct_3d.pack(_x.af0, _x.af1, _x.tgd))
        length = len(val1.isc)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(val1.isc.tostring())
      _x = self
      buff.write(_struct_2Id.pack(_x.lexion.t0.secs, _x.lexion.t0.nsecs, _x.lexion.tspan))
      buff.write(self.lexion.pos0.tostring())
      buff.write(self.lexion.coefs.tostring())
      length = len(self.wlbias)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.wlbias.tostring())
      length = len(self.glo_cpbias)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.glo_cpbias.tostring())
      _x = self.glo_fcn
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(_x))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(_x))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    try:
      if self.eph is None:
        self.eph = None
      if self.geph is None:
        self.geph = None
      if self.seph is None:
        self.seph = None
      if self.peph is None:
        self.peph = None
      if self.pclk is None:
        self.pclk = None
      if self.alm is None:
        self.alm = None
      if self.tec is None:
        self.tec = None
      if self.stec is None:
        self.stec = None
      if self.erp is None:
        self.erp = rtkrcv.msg.erp_t()
      if self.lamcwl is None:
        self.lamcwl = None
      if self.codebias is None:
        self.codebias = None
      if self.pcvs is None:
        self.pcvs = None
      if self.sbssat is None:
        self.sbssat = rtkrcv.msg.sbssat_t()
      if self.sbsion is None:
        self.sbsion = None
      if self.dgps is None:
        self.dgps = None
      if self.ssr is None:
        self.ssr = None
      if self.lexeph is None:
        self.lexeph = None
      if self.lexion is None:
        self.lexion = rtkrcv.msg.QzssIonosphereCorrection()
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.eph = []
      for i in range(0, length):
        val1 = rtkrcv.msg.Ephemeris()
        start = end
        end += 4
        (val1.sat,) = _struct_i.unpack(str[start:end])
        self.eph.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.geph = []
      for i in range(0, length):
        val1 = rtkrcv.msg.GlonassEphemeris()
        _x = val1
        start = end
        end += 24
        (_x.sat, _x.iode, _x.frq, _x.svh, _x.sva, _x.age,) = _struct_6i.unpack(str[start:end])
        _v103 = val1.toe
        _x = _v103
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        _v104 = val1.tof
        _x = _v104
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        _v105 = val1.pos
        _x = _v105
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _v106 = val1.vel
        _x = _v106
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _v107 = val1.acc
        _x = _v107
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _x = val1
        start = end
        end += 24
        (_x.taun, _x.gamn, _x.dtaun,) = _struct_3d.unpack(str[start:end])
        self.geph.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.seph = []
      for i in range(0, length):
        val1 = rtkrcv.msg.SbasEphemeris()
        start = end
        end += 4
        (val1.sat,) = _struct_i.unpack(str[start:end])
        _v108 = val1.t0
        _x = _v108
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        _v109 = val1.tof
        _x = _v109
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        _x = val1
        start = end
        end += 8
        (_x.sva, _x.svh,) = _struct_2i.unpack(str[start:end])
        _v110 = val1.pos
        _x = _v110
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _v111 = val1.vel
        _x = _v111
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _v112 = val1.acc
        _x = _v112
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _x = val1
        start = end
        end += 16
        (_x.af0, _x.af1,) = _struct_2d.unpack(str[start:end])
        self.seph.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.peph = []
      for i in range(0, length):
        val1 = rtkrcv.msg.PreciseEphemeris()
        _v113 = val1.time
        _x = _v113
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        start = end
        end += 4
        (val1.index,) = _struct_i.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        end += struct.calcsize(pattern)
        val1.pos = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sf'%length
        start = end
        end += struct.calcsize(pattern)
        val1.std = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
        self.peph.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.pclk = []
      for i in range(0, length):
        val1 = rtkrcv.msg.PreciseClock()
        _v114 = val1.time
        _x = _v114
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        start = end
        end += 4
        (val1.index,) = _struct_i.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        end += struct.calcsize(pattern)
        val1.clk = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sf'%length
        start = end
        end += struct.calcsize(pattern)
        val1.std = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
        self.pclk.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.alm = []
      for i in range(0, length):
        val1 = rtkrcv.msg.Almanac()
        _x = val1
        start = end
        end += 16
        (_x.sat, _x.svh, _x.svconf, _x.week,) = _struct_4i.unpack(str[start:end])
        _v115 = val1.toa
        start = end
        end += 4
        (_v115.seq,) = _struct_I.unpack(str[start:end])
        _v116 = _v115.stamp
        _x = _v116
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v115.frame_id = str[start:end].decode('utf-8')
        else:
          _v115.frame_id = str[start:end]
        _x = val1
        start = end
        end += 80
        (_x.A, _x.e, _x.i0, _x.OMG0, _x.omg, _x.M0, _x.OMGd, _x.toas, _x.f0, _x.f1,) = _struct_10d.unpack(str[start:end])
        self.alm.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.tec = []
      for i in range(0, length):
        val1 = rtkrcv.msg.TotalElectronContent()
        _v117 = val1.time
        _x = _v117
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%si'%length
        start = end
        end += struct.calcsize(pattern)
        val1.ndata = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
        start = end
        end += 8
        (val1.rb,) = _struct_d.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        end += struct.calcsize(pattern)
        val1.lats = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        end += struct.calcsize(pattern)
        val1.lons = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        end += struct.calcsize(pattern)
        val1.hgts = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        end += struct.calcsize(pattern)
        val1.data = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sf'%length
        start = end
        end += struct.calcsize(pattern)
        val1.rms = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
        self.tec.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.stec = []
      for i in range(0, length):
        val1 = rtkrcv.msg.stec_t()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        end += struct.calcsize(pattern)
        val1.pos = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%si'%length
        start = end
        end += struct.calcsize(pattern)
        val1.index = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
        _x = val1
        start = end
        end += 8
        (_x.n, _x.nmax,) = _struct_2i.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.data = []
        for i in range(0, length):
          val2 = rtkrcv.msg.stecd_t()
          _v118 = val2.header
          start = end
          end += 4
          (_v118.seq,) = _struct_I.unpack(str[start:end])
          _v119 = _v118.stamp
          _x = _v119
          start = end
          end += 8
          (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            _v118.frame_id = str[start:end].decode('utf-8')
          else:
            _v118.frame_id = str[start:end]
          _x = val2
          start = end
          end += 14
          (_x.sat, _x.slip, _x.iono, _x.rate, _x.rms,) = _struct_2B3f.unpack(str[start:end])
          val1.data.append(val2)
        self.stec.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.erp.data = []
      for i in range(0, length):
        val1 = rtkrcv.msg.erpd_t()
        _x = val1
        start = end
        end += 56
        (_x.mjd, _x.xp, _x.yp, _x.xpr, _x.ypr, _x.ut1_utc, _x.lod,) = _struct_7d.unpack(str[start:end])
        self.erp.data.append(val1)
      start = end
      end += 32
      self.utc_gps = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=4)
      start = end
      end += 32
      self.utc_glo = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=4)
      start = end
      end += 32
      self.utc_gal = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=4)
      start = end
      end += 32
      self.utc_qzs = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=4)
      start = end
      end += 32
      self.utc_cmp = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=4)
      start = end
      end += 32
      self.utc_sbs = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=4)
      start = end
      end += 64
      self.ion_gps = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=8)
      start = end
      end += 32
      self.ion_gal = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=4)
      start = end
      end += 64
      self.ion_qzs = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=8)
      start = end
      end += 64
      self.ion_cmp = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=8)
      start = end
      end += 4
      (self.leaps,) = _struct_i.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.lamcwl = []
      for i in range(0, length):
        val1 = rtkrcv.msg.lam()
        _x = val1
        start = end
        end += 48
        (_x.L1, _x.L2, _x.L5, _x.L6, _x.L7, _x.L8,) = _struct_6d.unpack(str[start:end])
        self.lamcwl.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.codebias = []
      for i in range(0, length):
        val1 = rtkrcv.msg.cbias()
        _x = val1
        start = end
        end += 24
        (_x.p1_p2, _x.p1_c1, _x.p2_c2,) = _struct_3d.unpack(str[start:end])
        self.codebias.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.pcvs = []
      for i in range(0, length):
        val1 = rtkrcv.msg.AntennaParameter()
        start = end
        end += 4
        (val1.sat,) = _struct_i.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sb'%length
        start = end
        end += struct.calcsize(pattern)
        val1.type = numpy.frombuffer(str[start:end], dtype=numpy.int8, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sb'%length
        start = end
        end += struct.calcsize(pattern)
        val1.code = numpy.frombuffer(str[start:end], dtype=numpy.int8, count=length)
        _v120 = val1.ts
        _x = _v120
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        _v121 = val1.te
        _x = _v121
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        start = end
        end += 24
        val1.off = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
        start = end
        end += 152
        val1.var = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=19)
        self.pcvs.append(val1)
      _x = self
      start = end
      end += 12
      (_x.sbssat.iodp, _x.sbssat.nsat, _x.sbssat.tlat,) = _struct_3i.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.sbssat.sat = []
      for i in range(0, length):
        val1 = rtkrcv.msg.sbssatp_t()
        start = end
        end += 4
        (val1.sat,) = _struct_i.unpack(str[start:end])
        _v122 = val1.fcorr
        _v123 = _v122.t0
        _x = _v123
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        _x = _v122
        start = end
        end += 32
        (_x.prc, _x.rrc, _x.dt, _x.iodf, _x.udre, _x.ai,) = _struct_3di2h.unpack(str[start:end])
        _v124 = val1.lcorr
        _v125 = _v124.t0
        _x = _v125
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        start = end
        end += 4
        (_v124.iode,) = _struct_i.unpack(str[start:end])
        _v126 = _v124.dpos
        _x = _v126
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _v127 = _v124.dvel
        _x = _v127
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _x = _v124
        start = end
        end += 16
        (_x.daf0, _x.daf1s,) = _struct_2d.unpack(str[start:end])
        self.sbssat.sat.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.sbsion = []
      for i in range(0, length):
        val1 = rtkrcv.msg.sbsion_t()
        _x = val1
        start = end
        end += 8
        (_x.iodi, _x.nigp,) = _struct_2i.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.igp = []
        for i in range(0, length):
          val2 = rtkrcv.msg.sbsigp_t()
          _v128 = val2.t0
          _x = _v128
          start = end
          end += 8
          (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
          _x = val2
          start = end
          end += 10
          (_x.lat, _x.lon, _x.give, _x.delay,) = _struct_3hf.unpack(str[start:end])
          val1.igp.append(val2)
        self.sbsion.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.dgps = []
      for i in range(0, length):
        val1 = rtkrcv.msg.DifferentialGnss()
        _v129 = val1.t0
        _x = _v129
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        _x = val1
        start = end
        end += 28
        (_x.prc, _x.rrc, _x.iod, _x.udre,) = _struct_2did.unpack(str[start:end])
        self.dgps.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.ssr = []
      for i in range(0, length):
        val1 = rtkrcv.msg.ssr_t()
        _v130 = val1.t0
        _x = _v130
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        end += struct.calcsize(pattern)
        val1.udi = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%si'%length
        start = end
        end += struct.calcsize(pattern)
        val1.iod = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
        _x = val1
        start = end
        end += 12
        (_x.iode, _x.ura, _x.refd,) = _struct_3i.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        end += struct.calcsize(pattern)
        val1.deph = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        end += struct.calcsize(pattern)
        val1.ddeph = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        end += struct.calcsize(pattern)
        val1.dclk = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 8
        (val1.hrclk,) = _struct_d.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sf'%length
        start = end
        end += struct.calcsize(pattern)
        val1.cbias = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
        start = end
        end += 1
        (val1.update,) = _struct_B.unpack(str[start:end])
        self.ssr.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.lexeph = []
      for i in range(0, length):
        val1 = rtkrcv.msg.QzssEphemeris()
        _v131 = val1.toe
        _x = _v131
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        _v132 = val1.tof
        _x = _v132
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        _x = val1
        start = end
        end += 6
        (_x.sat, _x.health, _x.ura,) = _struct_i2B.unpack(str[start:end])
        _v133 = val1.pos
        _x = _v133
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _v134 = val1.vel
        _x = _v134
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _v135 = val1.acc
        _x = _v135
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _v136 = val1.jerk
        _x = _v136
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _x = val1
        start = end
        end += 24
        (_x.af0, _x.af1, _x.tgd,) = _struct_3d.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        end += struct.calcsize(pattern)
        val1.isc = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        self.lexeph.append(val1)
      _x = self
      start = end
      end += 16
      (_x.lexion.t0.secs, _x.lexion.t0.nsecs, _x.lexion.tspan,) = _struct_2Id.unpack(str[start:end])
      start = end
      end += 16
      self.lexion.pos0 = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=2)
      start = end
      end += 48
      self.lexion.coefs = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.wlbias = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.glo_cpbias = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.glo_fcn = str[start:end]
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill

_struct_I = genpy.struct_I
_struct_7d = struct.Struct("<7d")
_struct_10d = struct.Struct("<10d")
_struct_2did = struct.Struct("<2did")
_struct_3i = struct.Struct("<3i")
_struct_3hf = struct.Struct("<3hf")
_struct_2Id = struct.Struct("<2Id")
_struct_3d = struct.Struct("<3d")
_struct_B = struct.Struct("<B")
_struct_6d = struct.Struct("<6d")
_struct_6i = struct.Struct("<6i")
_struct_8d = struct.Struct("<8d")
_struct_2B3f = struct.Struct("<2B3f")
_struct_3di2h = struct.Struct("<3di2h")
_struct_19d = struct.Struct("<19d")
_struct_i2B = struct.Struct("<i2B")
_struct_2I = struct.Struct("<2I")
_struct_d = struct.Struct("<d")
_struct_i = struct.Struct("<i")
_struct_2d = struct.Struct("<2d")
_struct_4i = struct.Struct("<4i")
_struct_4d = struct.Struct("<4d")
_struct_2i = struct.Struct("<2i")
