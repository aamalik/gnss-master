/* Auto-generated by genmsg_cpp for file /home/asfandyar/gnss-master/rtkrcv/msg/Almanac.msg */
#ifndef RTKRCV_MESSAGE_ALMANAC_H
#define RTKRCV_MESSAGE_ALMANAC_H
#include <string>
#include <vector>
#include <map>
#include <ostream>
#include "ros/serialization.h"
#include "ros/builtin_message_traits.h"
#include "ros/message_operations.h"
#include "ros/time.h"

#include "ros/macros.h"

#include "ros/assert.h"

#include "std_msgs/Header.h"

namespace rtkrcv
{
template <class ContainerAllocator>
struct Almanac_ {
  typedef Almanac_<ContainerAllocator> Type;

  Almanac_()
  : sat(0)
  , svh(0)
  , svconf(0)
  , week(0)
  , toa()
  , A(0.0)
  , e(0.0)
  , i0(0.0)
  , OMG0(0.0)
  , omg(0.0)
  , M0(0.0)
  , OMGd(0.0)
  , toas(0.0)
  , f0(0.0)
  , f1(0.0)
  {
  }

  Almanac_(const ContainerAllocator& _alloc)
  : sat(0)
  , svh(0)
  , svconf(0)
  , week(0)
  , toa(_alloc)
  , A(0.0)
  , e(0.0)
  , i0(0.0)
  , OMG0(0.0)
  , omg(0.0)
  , M0(0.0)
  , OMGd(0.0)
  , toas(0.0)
  , f0(0.0)
  , f1(0.0)
  {
  }

  typedef int32_t _sat_type;
  int32_t sat;

  typedef int32_t _svh_type;
  int32_t svh;

  typedef int32_t _svconf_type;
  int32_t svconf;

  typedef int32_t _week_type;
  int32_t week;

  typedef  ::std_msgs::Header_<ContainerAllocator>  _toa_type;
   ::std_msgs::Header_<ContainerAllocator>  toa;

  typedef double _A_type;
  double A;

  typedef double _e_type;
  double e;

  typedef double _i0_type;
  double i0;

  typedef double _OMG0_type;
  double OMG0;

  typedef double _omg_type;
  double omg;

  typedef double _M0_type;
  double M0;

  typedef double _OMGd_type;
  double OMGd;

  typedef double _toas_type;
  double toas;

  typedef double _f0_type;
  double f0;

  typedef double _f1_type;
  double f1;


  typedef boost::shared_ptr< ::rtkrcv::Almanac_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::rtkrcv::Almanac_<ContainerAllocator>  const> ConstPtr;
  boost::shared_ptr<std::map<std::string, std::string> > __connection_header;
}; // struct Almanac
typedef  ::rtkrcv::Almanac_<std::allocator<void> > Almanac;

typedef boost::shared_ptr< ::rtkrcv::Almanac> AlmanacPtr;
typedef boost::shared_ptr< ::rtkrcv::Almanac const> AlmanacConstPtr;


template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const  ::rtkrcv::Almanac_<ContainerAllocator> & v)
{
  ros::message_operations::Printer< ::rtkrcv::Almanac_<ContainerAllocator> >::stream(s, "", v);
  return s;}

} // namespace rtkrcv

namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::rtkrcv::Almanac_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::rtkrcv::Almanac_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::rtkrcv::Almanac_<ContainerAllocator> > {
  static const char* value() 
  {
    return "02371516dbcab8da95b5821d7089f77e";
  }

  static const char* value(const  ::rtkrcv::Almanac_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0x02371516dbcab8daULL;
  static const uint64_t static_value2 = 0x95b5821d7089f77eULL;
};

template<class ContainerAllocator>
struct DataType< ::rtkrcv::Almanac_<ContainerAllocator> > {
  static const char* value() 
  {
    return "rtkrcv/Almanac";
  }

  static const char* value(const  ::rtkrcv::Almanac_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::rtkrcv::Almanac_<ContainerAllocator> > {
  static const char* value() 
  {
    return "# The almanac consists of coarse orbit and status information for each satellite in the constellation, an ionospheric model, and information to relate GNSS derived time to Coordinated Universal Time (UTC)\n\
\n\
int32 sat                     # satellite number\n\
int32 svh                     # sv health (0:ok)\n\
int32 svconf                  # as and sv config\n\
int32 week                    # GPS/QZS: gps week, GAL: galileo week\n\
Header toa                    # Toa\n\
\n\
# SV orbit parameters\n\
float64 A\n\
float64 e\n\
float64 i0\n\
float64 OMG0\n\
float64 omg\n\
float64 M0\n\
float64 OMGd\n\
\n\
float64 toas                  # Toa (s) in week\n\
\n\
# SV clock parameters (af0,af1)\n\
float64 f0\n\
float64 f1\n\
================================================================================\n\
MSG: std_msgs/Header\n\
# Standard metadata for higher-level stamped data types.\n\
# This is generally used to communicate timestamped data \n\
# in a particular coordinate frame.\n\
# \n\
# sequence ID: consecutively increasing ID \n\
uint32 seq\n\
#Two-integer timestamp that is expressed as:\n\
# * stamp.secs: seconds (stamp_secs) since epoch\n\
# * stamp.nsecs: nanoseconds since stamp_secs\n\
# time-handling sugar is provided by the client library\n\
time stamp\n\
#Frame this data is associated with\n\
# 0: no frame\n\
# 1: global frame\n\
string frame_id\n\
\n\
";
  }

  static const char* value(const  ::rtkrcv::Almanac_<ContainerAllocator> &) { return value(); } 
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::rtkrcv::Almanac_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.sat);
    stream.next(m.svh);
    stream.next(m.svconf);
    stream.next(m.week);
    stream.next(m.toa);
    stream.next(m.A);
    stream.next(m.e);
    stream.next(m.i0);
    stream.next(m.OMG0);
    stream.next(m.omg);
    stream.next(m.M0);
    stream.next(m.OMGd);
    stream.next(m.toas);
    stream.next(m.f0);
    stream.next(m.f1);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct Almanac_
} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::rtkrcv::Almanac_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const  ::rtkrcv::Almanac_<ContainerAllocator> & v) 
  {
    s << indent << "sat: ";
    Printer<int32_t>::stream(s, indent + "  ", v.sat);
    s << indent << "svh: ";
    Printer<int32_t>::stream(s, indent + "  ", v.svh);
    s << indent << "svconf: ";
    Printer<int32_t>::stream(s, indent + "  ", v.svconf);
    s << indent << "week: ";
    Printer<int32_t>::stream(s, indent + "  ", v.week);
    s << indent << "toa: ";
s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.toa);
    s << indent << "A: ";
    Printer<double>::stream(s, indent + "  ", v.A);
    s << indent << "e: ";
    Printer<double>::stream(s, indent + "  ", v.e);
    s << indent << "i0: ";
    Printer<double>::stream(s, indent + "  ", v.i0);
    s << indent << "OMG0: ";
    Printer<double>::stream(s, indent + "  ", v.OMG0);
    s << indent << "omg: ";
    Printer<double>::stream(s, indent + "  ", v.omg);
    s << indent << "M0: ";
    Printer<double>::stream(s, indent + "  ", v.M0);
    s << indent << "OMGd: ";
    Printer<double>::stream(s, indent + "  ", v.OMGd);
    s << indent << "toas: ";
    Printer<double>::stream(s, indent + "  ", v.toas);
    s << indent << "f0: ";
    Printer<double>::stream(s, indent + "  ", v.f0);
    s << indent << "f1: ";
    Printer<double>::stream(s, indent + "  ", v.f1);
  }
};


} // namespace message_operations
} // namespace ros

#endif // RTKRCV_MESSAGE_ALMANAC_H

